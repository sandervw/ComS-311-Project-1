import java.util.ArrayList;

public class HashTable {
	
	private int p;

	private Tuple[] contents;
	private HashFunction h;
	
	/*
	 *  Finds the smallest prime integer p whose value is at least size. Creates
	 *	a hash table of size p where each cell initially is NULL. It will determine the hash function to be
	 *	used in the hash table by creating the object new HashFunction(p).
	 */
	public HashTable(int size){
		this.p = HelperClass.getPrime(size);
		contents = new Tuple[p];
		h = new HashFunction(p);
	}
	
	//Returns the maximum load of the hash table
	public int maxLoad(){
		int result = 0;
		for(int i = 0; i < contents.length; i++){
			Tuple temp = contents[i];
			int counter = 0;
			while(temp != null){
				counter++;
				temp = temp.getNext();
			}
			if(counter>= result) result = counter;
		}
		return result;
	}
	//Returns the average load of the hash table
	//Average load is not the same as load factor
	//Average load is sum of contents[i]/number of i, where i is not null
	public int averageLoad(){
		int nonNullLists = 0;
		for(int i = 0; i < contents.length; i++){
			Tuple temp = contents[i];
			if(temp!= null) nonNullLists +=1;
		}
		return this.numElements()/nonNullLists;
	}
	//returns the current size of the hash table
	public int size() {
		return p;
	}
	//returns the number of Tuples that are currently stored in the hash table.
	public int numElements() {
		int result = 0;
		for(int i = 0; i < contents.length; i++){
			Tuple temp = contents[i];
			int counter = 0;
			while(temp != null){
				counter++;
				temp = temp.getNext();
			}
			result += counter;
		}
		return result;
	}
	
	// return the load factor which is numElements()/size()
	public double loadFactor(){
		return (numElements()/size());
	}
	
	/*
	 * Adds the tuple t to the hash table; places t in the list pointed by the cell h(t.getKey())
	 * where h is the hash function that is being used. When the load factors becomes bigger than 0.7,
	 * then it (approximately) doubles the size of the hash table and rehashes all the elements (tuples) to
	 * the new hash table. The size of the new hash table must be: Smallest prime integer whose value is
	 * at least twice the current size.
	 */
	public void add(Tuple t) {
		//Find out which array list this is going into by hashing t.
		int hash = h.hash(t.getKey());
		//add the tuple into the hash table
		if(contents[hash]==null) contents[hash] = t;
		else{
			Tuple temp = contents[hash];
			while(temp.getNext() != null){
				temp = temp.getNext();
			}
			temp.setNext(t);
		}
		//Then we find the new load factor, and see if its bigger than 0.7.
		if(this.loadFactor() > .7){
			p = HelperClass.getPrime(2*p);
			Tuple[] newTable = contents.clone();
			contents = new Tuple[p]; 
			for(int i = 0; i < newTable.length; i++){
				Tuple temp = newTable[i];
				this.add(temp);
				while(temp != null){
					temp = temp.getNext();
					this.add(temp);
				}
			}
		}
	}
	
	/*
	 * returns an array list of Tuples (in the hash table) whose key equals k. If no such
	 * Tuples exist, returns an empty list. Note that the type of this method must be ArrayList<Tuple>
	 * 
	 * 
	 */
	public ArrayList<Tuple> search(int k) {
		//hash the value of k to get the index of the hashtable
		int hash = h.hash(k);
		ArrayList<Tuple> result = new ArrayList<Tuple>();
		if(contents[hash] == null) return result;
		else{
			Tuple temp = contents[hash];
			while(temp != null){
				result.add(temp);
				temp = temp.getNext();
			}
		}
		return result;
	}
	
	//Removes the Tuple t from the hash table.
	public void remove(Tuple t){
		int hash = h.hash(t.getKey());
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//?????????????????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//contents
		//????????????????????????????????????????????????????????????????[h.hash(t.getKey())][t.]//Referenc
		//????????????????????????????????????????????????????????????????e to matching element??????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
		//????????????????????????????????????????????????????????????????
	}
	
}
